<FUNCTIONREFERENCE>
<FUNCTION>
<CELL>abs(x)</CELL>
<CELL>Absolute value (per component).</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>acos(x)</CELL>
<CELL>Returns the arccosine of each component of x. Each component should be in the range [-1, 1]</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>all(x)</CELL>
<CELL>Test if all components of x are nonzero.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>AllMemoryBarrier</CELL>
<CELL>Blocks execution of all threads in a group until all memory accesses have been completed.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>AllMemoryBarrierWithGroupSync</CELL>
<CELL>Blocks execution of all threads in a group until all memory accesses have been completed and all threads in the group have reached this call.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>any(x)</CELL>
<CELL>Test if any component of x is nonzero.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asdouble</CELL>
<CELL>Reinterprets a cast value into a double.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asfloat</CELL>
<CELL>Reinterprets the bit pattern of a 64-bit type into a float.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asfloat</CELL>
<CELL>Convert the input type to a float.</CELL>
<CELL>4</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asin(x)</CELL>
<CELL>Returns the arcsine of each component of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asint</CELL>
<CELL>Reinterprets the bit pattern of a 64-bit type to an int.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asint</CELL>
<CELL>Convert the input type to an integer.</CELL>
<CELL>4</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asuint</CELL>
<CELL>Reinterprets the bit pattern of a 64-bit type to a uint</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>asuint</CELL>
<CELL>Convert the input type to an unsigned integer.</CELL>
<CELL>4</CELL>
</FUNCTION>
<FUNCTION>
<CELL>atan(x)</CELL>
<CELL>Returns the arctangent of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>atan2(x, y)</CELL>
<CELL>Returns the arctangent of two values (x, y).</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ceil(x)</CELL>
<CELL>Returns the smallest integer which is greater than or equal to x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>clamp(x, min, max)</CELL>
<CELL>Clamps x to the range [min, max].</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>clip(x)</CELL>
<CELL>Discards the current pixel, if any component of x is less than zero.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>cos(x)</CELL>
<CELL>Returns the cosine of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>cosh(x)</CELL>
<CELL>Returns the hyperbolic cosine of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>countbits</CELL>
<CELL>Counts the number of bits (per component) in the input integer</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>cross(a, b)</CELL>
<CELL>Returns the cross product of two 3D vectors a and b</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>D3DCOLORtoUBYTE4(x)</CELL>
<CELL>Swizzles and scales components of the 4D vector x to compensate for the lack of UBYTE4 support in some hardware</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ddx(x)</CELL>
<CELL>Returns the partial derivative of x with respect to the screen-space x-coordinate</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ddx_coarse</CELL>
<CELL>Computes a low precision partial derivative with respect to the screen-space x-coordinate</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ddx_fine</CELL>
<CELL>Computes a high precision partial derivative with respect to the screen-space x-coordinate</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ddy(x)</CELL>
<CELL>Returns the partial derivative of x with respect to the screen-space y-coordinate</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ddy_coarse</CELL>
<CELL>Computes a low precision partial derivative with respect to the screen-space y-coordinate</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ddy_fine</CELL>
<CELL>Computes a high precision partial derivative with respect to the screen-space y-coordinate</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>degrees(x)</CELL>
<CELL>Converts x from radians to degrees</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>determinant(m)</CELL>
<CELL>Returns the determinant of the square matrix m</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>DeviceMemoryBarrier</CELL>
<CELL>Blocks execution of all threads in a group until all device memory accesses have been completed</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>DeviceMemoryBarrierWithGroupSync</CELL>
<CELL>Blocks execution of all threads in a group until all device memory accesses have been completed and all threads in the group have reached this call</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>distance(a, b)</CELL>
<CELL>Returns the distance between two points a and b</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>dot(a, b)</CELL>
<CELL>Returns the dot product of two vectors a and b</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>dst</CELL>
<CELL>Calculates a distance vector</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>EvaluateAtFUNCTIONibuteAtCentroid</CELL>
<CELL>Evaluates at the pixel centroid</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>EvaluateAtFUNCTIONibuteAtSample</CELL>
<CELL>Evaluates at the indexed sample location</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>EvaluateAtFUNCTIONibuteSnapped</CELL>
<CELL>Evaluates at the pixel cenFUNCTIONoid with an offset</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>exp(x)</CELL>
<CELL>Returns the base-e exponent of x</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>exp2(x)</CELL>
<CELL>Base 2 exponent of x (per component)</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>f16tof32</CELL>
<CELL>Converts the float16 stored in the low-half of the uint to a float</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>f32tof16</CELL>
<CELL>Converts an input into a float16 type</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>faceforward(n, i, ng)</CELL>
<CELL>Returns -n * sign(dot(i, ng))</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>firstbithigh</CELL>
<CELL>Gets the location of the first set bit starting from the highest order bit and working downward, per component</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>firstbitlow</CELL>
<CELL>Returns the location of the first set bit starting from the lowest order bit and working upward, per component</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>floor(x)</CELL>
<CELL>Returns the greatest integer which is less than or equal to x</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>fmod(a, b)</CELL>
<CELL>Returns the floating point remainder f of a / b such that a = i * b + f, where i is an integer, f has the same sign as x, and the absolute value of f is less than the absolute value of b.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>frac(x)</CELL>
<CELL>Returns the fractional part f of x, such that f is a value greater than or equal to 0, and less than 1.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>frexp(x, out exp)</CELL>
<CELL>Returns the mantissa and exponent of x. frexp returns the mantissa, and the exponent is stored in the output parameter exp. If x is 0, the function returns 0 for both the mantissa and the exponent.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>fwidth(x)</CELL>
<CELL>Returns abs(ddx(x)) + abs(ddy(x))</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>GeFUNCTIONenderTargetSampleCount</CELL>
<CELL>Returns the number of render-target samples</CELL>
<CELL>4</CELL>
</FUNCTION>
<FUNCTION>
<CELL>GeFUNCTIONenderTargetSamplePosition</CELL>
<CELL>Returns a sample position (x,y) for a given sample index</CELL>
<CELL>4</CELL>
</FUNCTION>
<FUNCTION>
<CELL>GroupMemoryBarrier</CELL>
<CELL>Blocks execution of all threads in a group until all group shared accesses have been completed</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>GroupMemoryBarrierWithGroupSync</CELL>
<CELL>Blocks execution of all threads in a group until all group shared accesses have been completed and all threads in the group have reached this call</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedAdd</CELL>
<CELL>Performs a guaranteed atomic add of value to the dest resource variable</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedAnd</CELL>
<CELL>Performs a guaranteed atomic and</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedCompareExchange</CELL>
<CELL>Atomically compares the input to the comparison value and exchanges the result</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedCompareStore</CELL>
<CELL>Atomically compares the input to the comparison value</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedExchange</CELL>
<CELL>Assigns value to dest and returns the original value. </CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedMax</CELL>
<CELL>Performs a guaranteed atomic max</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedMin</CELL>
<CELL>Performs a guaranteed atomic min</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedOr</CELL>
<CELL>Performs a guaranteed atomic or</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>InterlockedXor</CELL>
<CELL>Performs a guaranteed atomic xor</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>isfinite(x)</CELL>
<CELL>Returns true if x is finite, false otherwise</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>isinf(x)</CELL>
<CELL>Returns true if x is +INF or -INF, false otherwise</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>isnan(x)</CELL>
<CELL>Returns true if x is NAN or QNAN, false otherwise</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ldexp(x, exp)</CELL>
<CELL>Returns x * 2exp</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>length(v)</CELL>
<CELL>Returns the length of the vector v</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>lerp(a, b, s)</CELL>
<CELL>Returns a + s(b - a). This linearly interpolates between a and b, such that the return value is a when s is 0, and b when s is 1.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>lit(ndotl, ndoth, m)</CELL>
<CELL>Returns a lighting vector (ambient, diffuse, specular, 1): 
ambient = 1; 
diffuse = (ndotl &lt; 0) ? 0 : ndotl; 
specular = (ndotl &lt; 0) || (ndoth &lt; 0) ? 0 : (ndoth * m);</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>log(x)</CELL>
<CELL>Returns the base-e logarithm of x. If x is negative, the function returns indefinite. If x is 0, the function returns +INF.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>log10(x)</CELL>
<CELL>Returns the base-10 logarithm of x. If x is negative, the function returns indefinite. If x is 0, the function returns +INF.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>log2(x)</CELL>
<CELL>Returns the base-2 logarithm of x. If x is negative, the function returns indefinite. If x is 0, the function returns +INF.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>mad</CELL>
<CELL>Performs an arithmetic multiply/add operation on three values</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>max(x, y)</CELL>
<CELL>Selects the greater of x and y</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>min(x, y)</CELL>
<CELL>Selects the lesser of x and y</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>modf(x, out ip)</CELL>
<CELL>Splits the value x into fractional and integer parts, each of which has the same sign and x. The signed fractional portion of x is returned. The integer portion is stored in the output parameter ip.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>mul(a, b)</CELL>
<CELL>Performs matrix multiplication between a and b. If a is a vector, it is treated as a row vector. If b is a vector, it is treated as a column vector. The inner dimension a-columns and b-rows must be equal. The result has the dimension a-rows x b-columns.</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>noise(x)</CELL>
<CELL>Generates a random value using the Perlin-noise algorithm</CELL>
<CELL>4</CELL>
</FUNCTION>
<FUNCTION>
<CELL>normalize(v)</CELL>
<CELL>Returns the normalized vector v / length(v). If the length of v is 0, the result is indefinite.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>pow(x, y)</CELL>
<CELL>Returns the specified value x raised to the specified power y.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>Process2DQuadTessFactorsAvg</CELL>
<CELL>Generates the corrected tessellation factors for a quad patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>Process2DQuadTessFactorsMax</CELL>
<CELL>Generates the corrected tessellation factors for a quad patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>Process2DQuadTessFactorsMin</CELL>
<CELL>Generates the corrected tessellation factors for a quad patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessIsolineTessFactors</CELL>
<CELL>Generates the rounded tessellation factors for an isoline</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessQuadTessFactorsAvg</CELL>
<CELL>Generates the corrected tessellation factors for a quad patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessQuadTessFactorsMax</CELL>
<CELL>Generates the corrected tessellation factors for a quad patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessQuadTessFactorsMin</CELL>
<CELL>Generates the corrected tessellation factors for a quad patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessTriTessFactorsAvg</CELL>
<CELL>Generates the corrected tessellation factors for a tri patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessTriTessFactorsMax</CELL>
<CELL>Generates the corrected tessellation factors for a tri patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>ProcessTriTessFactorsMin</CELL>
<CELL>Generates the corrected tessellation factors for a tri patch</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>radians(x)</CELL>
<CELL>Converts x from degrees to radians.</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>rcp</CELL>
<CELL>Calculates a fast, approximate, per-component reciprocal.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>reflect(i, n)</CELL>
<CELL>Returns the reflection vector v, given the entering ray direction i, and the surface normal n. Such that v = i - 2 * dot(i, n) * n</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>refract(i, n, eta)</CELL>
<CELL>Returns the refraction vector v, given the entering ray direction i, the surface normal n, and the relative index of refraction eta. If the angle between i and n is too great for a given eta, refract returns (0,0,0).</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>reversebits</CELL>
<CELL>Reverses the order of the bits, per component.</CELL>
<CELL>5</CELL>
</FUNCTION>
<FUNCTION>
<CELL>round(x)</CELL>
<CELL>Rounds x to the nearest integer.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>rsqrt(x)</CELL>
<CELL>Returns 1 / sqrt(x).</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>saturate(x)</CELL>
<CELL>Clamps x to the range [0, 1].</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>sign(x)</CELL>
<CELL>Computes the sign of x. Returns -1 if x is less than 0, 0 if x equals 0, and 1 if x is greater than zero.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>sin(x)</CELL>
<CELL>Returns the sine of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>sincos(x, out s, out c)</CELL>
<CELL>Returns the sine and cosine of x. sin(x) is stored in the output parameter s. cos(x) is stored in the output parameter c.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>sinh(x)</CELL>
<CELL>Returns the hyperbolic sine of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>smoothstep(min, max, x)</CELL>
<CELL>Returns 0 if x &lt; min. Returns 1 if x &gt; max. Returns a smooth Hermite interpolation between 0 and 1, if x is in the range [min, max].</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>sqrt(x)</CELL>
<CELL>Square root of x (per component)</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>step(a, x)</CELL>
<CELL>Returns (x &gt;= a) ? 1 : 0</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tan(x)</CELL>
<CELL>Returns the tangent of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tanh(x)</CELL>
<CELL>Returns the hyperbolic tangent of x.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex1D(s, t)</CELL>
<CELL>1-D texture lookup. s is a sampler or a sampler1D object. t is a scalar.</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex1D(s, t, ddx, ddy)</CELL>
<CELL>1-D texture lookup, with derivatives. s is a sampler or sampler1D object. t, ddx, and ddy are scalars.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex1Dbias(s, t)</CELL>
<CELL>1-D biased texture lookup. s is a sampler or sampler1D object. t is a 4-D vector. The mip level is biased by t.w before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex1Dgrad</CELL>
<CELL>1D texture lookup with a gradient</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex1Dlod</CELL>
<CELL>1D texture lookup with LOD</CELL>
<CELL>3_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex1Dproj(s, t)</CELL>
<CELL>1-D projective texture lookup. s is a sampler or sampler1D object. t is a 4-D vector. t is divided by its last component before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex2D(s, t)</CELL>
<CELL>2-D texture lookup. s is a sampler or a sampler2D object. t is a 2-D texture coordinate.</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex2D(s, t, ddx, ddy)</CELL>
<CELL>2-D texture lookup, with derivatives. s is a sampler or sampler2D object. t, ddx, and ddy are 2-D vectors.</CELL>
<CELL>2</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex2Dbias(s, t)</CELL>
<CELL>2-D biased texture lookup. s is a sampler or sampler2D object. t is a 4-D vector. The mip level is biased by t.w before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex2Dgrad</CELL>
<CELL>2D texture lookup with a gradient</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex2Dlod</CELL>
<CELL>2D texture lookup with LOD</CELL>
<CELL>3</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex2Dproj(s, t)</CELL>
<CELL>2-D projective texture lookup. s is a sampler or sampler2D object. t is a 4-D vector. t is divided by its last component before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex3D(s, t)</CELL>
<CELL>3-D volume texture lookup. s is a sampler or a sampler3D object. t is a 3-D texture coordinate.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex3D(s, t, ddx, ddy)</CELL>
<CELL>3-D volume texture lookup, with derivatives. s is a sampler or sampler3D object. t, ddx, and ddy are 3-D vectors.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex3Dbias</CELL>
<CELL>3-D biased texture lookup. s is a sampler or sampler3D object. t is a 4-D vector. The mip level is biased by t.w before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex3Dgrad</CELL>
<CELL>3D texture lookup with a gradient</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex3Dlod</CELL>
<CELL>3D texture lookup with LOD</CELL>
<CELL>3_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>tex3Dproj(s, t)</CELL>
<CELL>3-D projective volume texture lookup. s is a sampler or sampler3D object. t is a 4-D vector. t is divided by its last component before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>texCUBE(s, t)</CELL>
<CELL>3-D cube texture lookup.  s is a sampler or a samplerCUBE object.  t is a 3-D texture coordinate.</CELL>
<CELL>1_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>texCUBE(s, t, ddx, ddy)</CELL>
<CELL>3-D cube texture lookup, with derivatives. s is a sampler or samplerCUBE object. t, ddx, and ddy are 3-D vectors.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>texCUBEbias(s, t)</CELL>
<CELL>3-D biased cube texture lookup. s is a sampler or samplerCUBE object. t is a 4-dimensional vector. The mip level is biased by t.w before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>texCUBEgrad</CELL>
<CELL>Cube texture lookup with a gradient</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>texCUBElod</CELL>
<CELL>Cube texture lookup with LOD</CELL>
<CELL>3_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>texCUBEproj(s, t)</CELL>
<CELL>3-D projective cube texture lookup. s is a sampler or samplerCUBE object. t is a 4-D vector. t is divided by its last component before the lookup takes place.</CELL>
<CELL>2_1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>transpose(m)</CELL>
<CELL>Returns the transpose of the matrix m. If the source is dimension m-rows x m-columns, the result is dimension m-columns x m-rows.</CELL>
<CELL>1</CELL>
</FUNCTION>
<FUNCTION>
<CELL>trunc(x)</CELL>
<CELL>Truncates a floating-point x an integer.</CELL>
<CELL>1</CELL>
</FUNCTION>
</FUNCTIONREFERENCE>